/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Auth Tutorial API
 * API documentation for the auth-tutorial project. This is a comprehensive REST API built with NestJS.
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type { CreateEventDto, UpdateEventDto } from '.././models';

import { customFetch } from '../../client';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Create a new event
 */
export type eventsControllerCreateResponse201 = {
  data: void;
  status: 201;
};

export type eventsControllerCreateResponse401 = {
  data: void;
  status: 401;
};

export type eventsControllerCreateResponseSuccess = eventsControllerCreateResponse201 & {
  headers: Headers;
};
export type eventsControllerCreateResponseError = eventsControllerCreateResponse401 & {
  headers: Headers;
};

export type eventsControllerCreateResponse =
  | eventsControllerCreateResponseSuccess
  | eventsControllerCreateResponseError;

export const getEventsControllerCreateUrl = () => {
  return `/api/events`;
};

export const eventsControllerCreate = async (
  createEventDto: CreateEventDto,
  options?: RequestInit
): Promise<eventsControllerCreateResponse> => {
  return customFetch<eventsControllerCreateResponse>(getEventsControllerCreateUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createEventDto),
  });
};

export const getEventsControllerCreateMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventsControllerCreate>>,
    TError,
    { data: CreateEventDto },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eventsControllerCreate>>,
  TError,
  { data: CreateEventDto },
  TContext
> => {
  const mutationKey = ['eventsControllerCreate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eventsControllerCreate>>,
    { data: CreateEventDto }
  > = (props) => {
    const { data } = props ?? {};

    return eventsControllerCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EventsControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof eventsControllerCreate>>
>;
export type EventsControllerCreateMutationBody = CreateEventDto;
export type EventsControllerCreateMutationError = void;

/**
 * @summary Create a new event
 */
export const useEventsControllerCreate = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eventsControllerCreate>>,
      TError,
      { data: CreateEventDto },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof eventsControllerCreate>>,
  TError,
  { data: CreateEventDto },
  TContext
> => {
  const mutationOptions = getEventsControllerCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get all events for current user
 */
export type eventsControllerFindAllResponse200 = {
  data: void;
  status: 200;
};

export type eventsControllerFindAllResponse401 = {
  data: void;
  status: 401;
};

export type eventsControllerFindAllResponseSuccess = eventsControllerFindAllResponse200 & {
  headers: Headers;
};
export type eventsControllerFindAllResponseError = eventsControllerFindAllResponse401 & {
  headers: Headers;
};

export type eventsControllerFindAllResponse =
  | eventsControllerFindAllResponseSuccess
  | eventsControllerFindAllResponseError;

export const getEventsControllerFindAllUrl = () => {
  return `/api/events`;
};

export const eventsControllerFindAll = async (
  options?: RequestInit
): Promise<eventsControllerFindAllResponse> => {
  return customFetch<eventsControllerFindAllResponse>(getEventsControllerFindAllUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getEventsControllerFindAllQueryKey = () => {
  return [`/api/events`] as const;
};

export const getEventsControllerFindAllQueryOptions = <
  TData = Awaited<ReturnType<typeof eventsControllerFindAll>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof eventsControllerFindAll>>, TError, TData>
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getEventsControllerFindAllQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof eventsControllerFindAll>>> = ({
    signal,
  }) => eventsControllerFindAll({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof eventsControllerFindAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EventsControllerFindAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof eventsControllerFindAll>>
>;
export type EventsControllerFindAllQueryError = void;

export function useEventsControllerFindAll<
  TData = Awaited<ReturnType<typeof eventsControllerFindAll>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof eventsControllerFindAll>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof eventsControllerFindAll>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useEventsControllerFindAll<
  TData = Awaited<ReturnType<typeof eventsControllerFindAll>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof eventsControllerFindAll>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof eventsControllerFindAll>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useEventsControllerFindAll<
  TData = Awaited<ReturnType<typeof eventsControllerFindAll>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof eventsControllerFindAll>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get all events for current user
 */

export function useEventsControllerFindAll<
  TData = Awaited<ReturnType<typeof eventsControllerFindAll>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof eventsControllerFindAll>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getEventsControllerFindAllQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get a single event by ID
 */
export type eventsControllerFindOneResponse200 = {
  data: void;
  status: 200;
};

export type eventsControllerFindOneResponse401 = {
  data: void;
  status: 401;
};

export type eventsControllerFindOneResponse403 = {
  data: void;
  status: 403;
};

export type eventsControllerFindOneResponse404 = {
  data: void;
  status: 404;
};

export type eventsControllerFindOneResponseSuccess = eventsControllerFindOneResponse200 & {
  headers: Headers;
};
export type eventsControllerFindOneResponseError = (
  | eventsControllerFindOneResponse401
  | eventsControllerFindOneResponse403
  | eventsControllerFindOneResponse404
) & {
  headers: Headers;
};

export type eventsControllerFindOneResponse =
  | eventsControllerFindOneResponseSuccess
  | eventsControllerFindOneResponseError;

export const getEventsControllerFindOneUrl = (id: string) => {
  return `/api/events/${id}`;
};

export const eventsControllerFindOne = async (
  id: string,
  options?: RequestInit
): Promise<eventsControllerFindOneResponse> => {
  return customFetch<eventsControllerFindOneResponse>(getEventsControllerFindOneUrl(id), {
    ...options,
    method: 'GET',
  });
};

export const getEventsControllerFindOneQueryKey = (id?: string) => {
  return [`/api/events/${id}`] as const;
};

export const getEventsControllerFindOneQueryOptions = <
  TData = Awaited<ReturnType<typeof eventsControllerFindOne>>,
  TError = void | void | void,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof eventsControllerFindOne>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getEventsControllerFindOneQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof eventsControllerFindOne>>> = ({
    signal,
  }) => eventsControllerFindOne(id, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof eventsControllerFindOne>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EventsControllerFindOneQueryResult = NonNullable<
  Awaited<ReturnType<typeof eventsControllerFindOne>>
>;
export type EventsControllerFindOneQueryError = void | void | void;

export function useEventsControllerFindOne<
  TData = Awaited<ReturnType<typeof eventsControllerFindOne>>,
  TError = void | void | void,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof eventsControllerFindOne>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof eventsControllerFindOne>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useEventsControllerFindOne<
  TData = Awaited<ReturnType<typeof eventsControllerFindOne>>,
  TError = void | void | void,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof eventsControllerFindOne>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof eventsControllerFindOne>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useEventsControllerFindOne<
  TData = Awaited<ReturnType<typeof eventsControllerFindOne>>,
  TError = void | void | void,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof eventsControllerFindOne>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get a single event by ID
 */

export function useEventsControllerFindOne<
  TData = Awaited<ReturnType<typeof eventsControllerFindOne>>,
  TError = void | void | void,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof eventsControllerFindOne>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getEventsControllerFindOneQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update an event
 */
export type eventsControllerUpdateResponse200 = {
  data: void;
  status: 200;
};

export type eventsControllerUpdateResponse401 = {
  data: void;
  status: 401;
};

export type eventsControllerUpdateResponse403 = {
  data: void;
  status: 403;
};

export type eventsControllerUpdateResponse404 = {
  data: void;
  status: 404;
};

export type eventsControllerUpdateResponseSuccess = eventsControllerUpdateResponse200 & {
  headers: Headers;
};
export type eventsControllerUpdateResponseError = (
  | eventsControllerUpdateResponse401
  | eventsControllerUpdateResponse403
  | eventsControllerUpdateResponse404
) & {
  headers: Headers;
};

export type eventsControllerUpdateResponse =
  | eventsControllerUpdateResponseSuccess
  | eventsControllerUpdateResponseError;

export const getEventsControllerUpdateUrl = (id: string) => {
  return `/api/events/${id}`;
};

export const eventsControllerUpdate = async (
  id: string,
  updateEventDto: UpdateEventDto,
  options?: RequestInit
): Promise<eventsControllerUpdateResponse> => {
  return customFetch<eventsControllerUpdateResponse>(getEventsControllerUpdateUrl(id), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateEventDto),
  });
};

export const getEventsControllerUpdateMutationOptions = <
  TError = void | void | void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventsControllerUpdate>>,
    TError,
    { id: string; data: UpdateEventDto },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eventsControllerUpdate>>,
  TError,
  { id: string; data: UpdateEventDto },
  TContext
> => {
  const mutationKey = ['eventsControllerUpdate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eventsControllerUpdate>>,
    { id: string; data: UpdateEventDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return eventsControllerUpdate(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EventsControllerUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof eventsControllerUpdate>>
>;
export type EventsControllerUpdateMutationBody = UpdateEventDto;
export type EventsControllerUpdateMutationError = void | void | void;

/**
 * @summary Update an event
 */
export const useEventsControllerUpdate = <TError = void | void | void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eventsControllerUpdate>>,
      TError,
      { id: string; data: UpdateEventDto },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof eventsControllerUpdate>>,
  TError,
  { id: string; data: UpdateEventDto },
  TContext
> => {
  const mutationOptions = getEventsControllerUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Delete an event
 */
export type eventsControllerRemoveResponse200 = {
  data: void;
  status: 200;
};

export type eventsControllerRemoveResponse401 = {
  data: void;
  status: 401;
};

export type eventsControllerRemoveResponse403 = {
  data: void;
  status: 403;
};

export type eventsControllerRemoveResponse404 = {
  data: void;
  status: 404;
};

export type eventsControllerRemoveResponseSuccess = eventsControllerRemoveResponse200 & {
  headers: Headers;
};
export type eventsControllerRemoveResponseError = (
  | eventsControllerRemoveResponse401
  | eventsControllerRemoveResponse403
  | eventsControllerRemoveResponse404
) & {
  headers: Headers;
};

export type eventsControllerRemoveResponse =
  | eventsControllerRemoveResponseSuccess
  | eventsControllerRemoveResponseError;

export const getEventsControllerRemoveUrl = (id: string) => {
  return `/api/events/${id}`;
};

export const eventsControllerRemove = async (
  id: string,
  options?: RequestInit
): Promise<eventsControllerRemoveResponse> => {
  return customFetch<eventsControllerRemoveResponse>(getEventsControllerRemoveUrl(id), {
    ...options,
    method: 'DELETE',
  });
};

export const getEventsControllerRemoveMutationOptions = <
  TError = void | void | void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventsControllerRemove>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eventsControllerRemove>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['eventsControllerRemove'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eventsControllerRemove>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return eventsControllerRemove(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EventsControllerRemoveMutationResult = NonNullable<
  Awaited<ReturnType<typeof eventsControllerRemove>>
>;

export type EventsControllerRemoveMutationError = void | void | void;

/**
 * @summary Delete an event
 */
export const useEventsControllerRemove = <TError = void | void | void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eventsControllerRemove>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof eventsControllerRemove>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getEventsControllerRemoveMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
